// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'repository_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BookShortInfo {
  int get id => throw _privateConstructorUsedError;
  DateTime get created => throw _privateConstructorUsedError;
  String? get previewUrl => throw _privateConstructorUsedError;
  bool get parsedName => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get parsedPage => throw _privateConstructorUsedError;
  int get pageCount => throw _privateConstructorUsedError;
  double get pageLoadedPercent => throw _privateConstructorUsedError;
  int get rate => throw _privateConstructorUsedError;
  List<String>? get tags => throw _privateConstructorUsedError;
  bool get hasMoreTags => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookShortInfoCopyWith<BookShortInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookShortInfoCopyWith<$Res> {
  factory $BookShortInfoCopyWith(
          BookShortInfo value, $Res Function(BookShortInfo) then) =
      _$BookShortInfoCopyWithImpl<$Res, BookShortInfo>;
  @useResult
  $Res call(
      {int id,
      DateTime created,
      String? previewUrl,
      bool parsedName,
      String name,
      bool parsedPage,
      int pageCount,
      double pageLoadedPercent,
      int rate,
      List<String>? tags,
      bool hasMoreTags});
}

/// @nodoc
class _$BookShortInfoCopyWithImpl<$Res, $Val extends BookShortInfo>
    implements $BookShortInfoCopyWith<$Res> {
  _$BookShortInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? previewUrl = freezed,
    Object? parsedName = null,
    Object? name = null,
    Object? parsedPage = null,
    Object? pageCount = null,
    Object? pageLoadedPercent = null,
    Object? rate = null,
    Object? tags = freezed,
    Object? hasMoreTags = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as DateTime,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      parsedName: null == parsedName
          ? _value.parsedName
          : parsedName // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parsedPage: null == parsedPage
          ? _value.parsedPage
          : parsedPage // ignore: cast_nullable_to_non_nullable
              as bool,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageLoadedPercent: null == pageLoadedPercent
          ? _value.pageLoadedPercent
          : pageLoadedPercent // ignore: cast_nullable_to_non_nullable
              as double,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasMoreTags: null == hasMoreTags
          ? _value.hasMoreTags
          : hasMoreTags // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookShortInfoImplCopyWith<$Res>
    implements $BookShortInfoCopyWith<$Res> {
  factory _$$BookShortInfoImplCopyWith(
          _$BookShortInfoImpl value, $Res Function(_$BookShortInfoImpl) then) =
      __$$BookShortInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      DateTime created,
      String? previewUrl,
      bool parsedName,
      String name,
      bool parsedPage,
      int pageCount,
      double pageLoadedPercent,
      int rate,
      List<String>? tags,
      bool hasMoreTags});
}

/// @nodoc
class __$$BookShortInfoImplCopyWithImpl<$Res>
    extends _$BookShortInfoCopyWithImpl<$Res, _$BookShortInfoImpl>
    implements _$$BookShortInfoImplCopyWith<$Res> {
  __$$BookShortInfoImplCopyWithImpl(
      _$BookShortInfoImpl _value, $Res Function(_$BookShortInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? previewUrl = freezed,
    Object? parsedName = null,
    Object? name = null,
    Object? parsedPage = null,
    Object? pageCount = null,
    Object? pageLoadedPercent = null,
    Object? rate = null,
    Object? tags = freezed,
    Object? hasMoreTags = null,
  }) {
    return _then(_$BookShortInfoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as DateTime,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      parsedName: null == parsedName
          ? _value.parsedName
          : parsedName // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parsedPage: null == parsedPage
          ? _value.parsedPage
          : parsedPage // ignore: cast_nullable_to_non_nullable
              as bool,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageLoadedPercent: null == pageLoadedPercent
          ? _value.pageLoadedPercent
          : pageLoadedPercent // ignore: cast_nullable_to_non_nullable
              as double,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      hasMoreTags: null == hasMoreTags
          ? _value.hasMoreTags
          : hasMoreTags // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$BookShortInfoImpl
    with DiagnosticableTreeMixin
    implements _BookShortInfo {
  const _$BookShortInfoImpl(
      {required this.id,
      required this.created,
      this.previewUrl,
      required this.parsedName,
      required this.name,
      required this.parsedPage,
      required this.pageCount,
      required this.pageLoadedPercent,
      required this.rate,
      final List<String>? tags,
      required this.hasMoreTags})
      : _tags = tags;

  @override
  final int id;
  @override
  final DateTime created;
  @override
  final String? previewUrl;
  @override
  final bool parsedName;
  @override
  final String name;
  @override
  final bool parsedPage;
  @override
  final int pageCount;
  @override
  final double pageLoadedPercent;
  @override
  final int rate;
  final List<String>? _tags;
  @override
  List<String>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool hasMoreTags;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BookShortInfo(id: $id, created: $created, previewUrl: $previewUrl, parsedName: $parsedName, name: $name, parsedPage: $parsedPage, pageCount: $pageCount, pageLoadedPercent: $pageLoadedPercent, rate: $rate, tags: $tags, hasMoreTags: $hasMoreTags)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BookShortInfo'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('created', created))
      ..add(DiagnosticsProperty('previewUrl', previewUrl))
      ..add(DiagnosticsProperty('parsedName', parsedName))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('parsedPage', parsedPage))
      ..add(DiagnosticsProperty('pageCount', pageCount))
      ..add(DiagnosticsProperty('pageLoadedPercent', pageLoadedPercent))
      ..add(DiagnosticsProperty('rate', rate))
      ..add(DiagnosticsProperty('tags', tags))
      ..add(DiagnosticsProperty('hasMoreTags', hasMoreTags));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookShortInfoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.previewUrl, previewUrl) ||
                other.previewUrl == previewUrl) &&
            (identical(other.parsedName, parsedName) ||
                other.parsedName == parsedName) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parsedPage, parsedPage) ||
                other.parsedPage == parsedPage) &&
            (identical(other.pageCount, pageCount) ||
                other.pageCount == pageCount) &&
            (identical(other.pageLoadedPercent, pageLoadedPercent) ||
                other.pageLoadedPercent == pageLoadedPercent) &&
            (identical(other.rate, rate) || other.rate == rate) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.hasMoreTags, hasMoreTags) ||
                other.hasMoreTags == hasMoreTags));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      created,
      previewUrl,
      parsedName,
      name,
      parsedPage,
      pageCount,
      pageLoadedPercent,
      rate,
      const DeepCollectionEquality().hash(_tags),
      hasMoreTags);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookShortInfoImplCopyWith<_$BookShortInfoImpl> get copyWith =>
      __$$BookShortInfoImplCopyWithImpl<_$BookShortInfoImpl>(this, _$identity);
}

abstract class _BookShortInfo implements BookShortInfo {
  const factory _BookShortInfo(
      {required final int id,
      required final DateTime created,
      final String? previewUrl,
      required final bool parsedName,
      required final String name,
      required final bool parsedPage,
      required final int pageCount,
      required final double pageLoadedPercent,
      required final int rate,
      final List<String>? tags,
      required final bool hasMoreTags}) = _$BookShortInfoImpl;

  @override
  int get id;
  @override
  DateTime get created;
  @override
  String? get previewUrl;
  @override
  bool get parsedName;
  @override
  String get name;
  @override
  bool get parsedPage;
  @override
  int get pageCount;
  @override
  double get pageLoadedPercent;
  @override
  int get rate;
  @override
  List<String>? get tags;
  @override
  bool get hasMoreTags;
  @override
  @JsonKey(ignore: true)
  _$$BookShortInfoImplCopyWith<_$BookShortInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PageForPagination {
  int get value => throw _privateConstructorUsedError;
  bool get isCurrent => throw _privateConstructorUsedError;
  bool get isSeparator => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PageForPaginationCopyWith<PageForPagination> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageForPaginationCopyWith<$Res> {
  factory $PageForPaginationCopyWith(
          PageForPagination value, $Res Function(PageForPagination) then) =
      _$PageForPaginationCopyWithImpl<$Res, PageForPagination>;
  @useResult
  $Res call({int value, bool isCurrent, bool isSeparator});
}

/// @nodoc
class _$PageForPaginationCopyWithImpl<$Res, $Val extends PageForPagination>
    implements $PageForPaginationCopyWith<$Res> {
  _$PageForPaginationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? isCurrent = null,
    Object? isSeparator = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
      isCurrent: null == isCurrent
          ? _value.isCurrent
          : isCurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      isSeparator: null == isSeparator
          ? _value.isSeparator
          : isSeparator // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PageForPaginationImplCopyWith<$Res>
    implements $PageForPaginationCopyWith<$Res> {
  factory _$$PageForPaginationImplCopyWith(_$PageForPaginationImpl value,
          $Res Function(_$PageForPaginationImpl) then) =
      __$$PageForPaginationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int value, bool isCurrent, bool isSeparator});
}

/// @nodoc
class __$$PageForPaginationImplCopyWithImpl<$Res>
    extends _$PageForPaginationCopyWithImpl<$Res, _$PageForPaginationImpl>
    implements _$$PageForPaginationImplCopyWith<$Res> {
  __$$PageForPaginationImplCopyWithImpl(_$PageForPaginationImpl _value,
      $Res Function(_$PageForPaginationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? isCurrent = null,
    Object? isSeparator = null,
  }) {
    return _then(_$PageForPaginationImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
      isCurrent: null == isCurrent
          ? _value.isCurrent
          : isCurrent // ignore: cast_nullable_to_non_nullable
              as bool,
      isSeparator: null == isSeparator
          ? _value.isSeparator
          : isSeparator // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$PageForPaginationImpl
    with DiagnosticableTreeMixin
    implements _PageForPagination {
  const _$PageForPaginationImpl(
      {required this.value,
      required this.isCurrent,
      required this.isSeparator});

  @override
  final int value;
  @override
  final bool isCurrent;
  @override
  final bool isSeparator;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PageForPagination(value: $value, isCurrent: $isCurrent, isSeparator: $isSeparator)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PageForPagination'))
      ..add(DiagnosticsProperty('value', value))
      ..add(DiagnosticsProperty('isCurrent', isCurrent))
      ..add(DiagnosticsProperty('isSeparator', isSeparator));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PageForPaginationImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.isCurrent, isCurrent) ||
                other.isCurrent == isCurrent) &&
            (identical(other.isSeparator, isSeparator) ||
                other.isSeparator == isSeparator));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value, isCurrent, isSeparator);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PageForPaginationImplCopyWith<_$PageForPaginationImpl> get copyWith =>
      __$$PageForPaginationImplCopyWithImpl<_$PageForPaginationImpl>(
          this, _$identity);
}

abstract class _PageForPagination implements PageForPagination {
  const factory _PageForPagination(
      {required final int value,
      required final bool isCurrent,
      required final bool isSeparator}) = _$PageForPaginationImpl;

  @override
  int get value;
  @override
  bool get isCurrent;
  @override
  bool get isSeparator;
  @override
  @JsonKey(ignore: true)
  _$$PageForPaginationImplCopyWith<_$PageForPaginationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookListResponse {
  List<BookShortInfo> get books => throw _privateConstructorUsedError;
  List<PageForPagination> get pages => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookListResponseCopyWith<BookListResponse> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookListResponseCopyWith<$Res> {
  factory $BookListResponseCopyWith(
          BookListResponse value, $Res Function(BookListResponse) then) =
      _$BookListResponseCopyWithImpl<$Res, BookListResponse>;
  @useResult
  $Res call({List<BookShortInfo> books, List<PageForPagination> pages});
}

/// @nodoc
class _$BookListResponseCopyWithImpl<$Res, $Val extends BookListResponse>
    implements $BookListResponseCopyWith<$Res> {
  _$BookListResponseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? books = null,
    Object? pages = null,
  }) {
    return _then(_value.copyWith(
      books: null == books
          ? _value.books
          : books // ignore: cast_nullable_to_non_nullable
              as List<BookShortInfo>,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<PageForPagination>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookListResponseImplCopyWith<$Res>
    implements $BookListResponseCopyWith<$Res> {
  factory _$$BookListResponseImplCopyWith(_$BookListResponseImpl value,
          $Res Function(_$BookListResponseImpl) then) =
      __$$BookListResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<BookShortInfo> books, List<PageForPagination> pages});
}

/// @nodoc
class __$$BookListResponseImplCopyWithImpl<$Res>
    extends _$BookListResponseCopyWithImpl<$Res, _$BookListResponseImpl>
    implements _$$BookListResponseImplCopyWith<$Res> {
  __$$BookListResponseImplCopyWithImpl(_$BookListResponseImpl _value,
      $Res Function(_$BookListResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? books = null,
    Object? pages = null,
  }) {
    return _then(_$BookListResponseImpl(
      books: null == books
          ? _value._books
          : books // ignore: cast_nullable_to_non_nullable
              as List<BookShortInfo>,
      pages: null == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<PageForPagination>,
    ));
  }
}

/// @nodoc

class _$BookListResponseImpl
    with DiagnosticableTreeMixin
    implements _BookListResponse {
  const _$BookListResponseImpl(
      {required final List<BookShortInfo> books,
      required final List<PageForPagination> pages})
      : _books = books,
        _pages = pages;

  final List<BookShortInfo> _books;
  @override
  List<BookShortInfo> get books {
    if (_books is EqualUnmodifiableListView) return _books;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_books);
  }

  final List<PageForPagination> _pages;
  @override
  List<PageForPagination> get pages {
    if (_pages is EqualUnmodifiableListView) return _pages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pages);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BookListResponse(books: $books, pages: $pages)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BookListResponse'))
      ..add(DiagnosticsProperty('books', books))
      ..add(DiagnosticsProperty('pages', pages));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookListResponseImpl &&
            const DeepCollectionEquality().equals(other._books, _books) &&
            const DeepCollectionEquality().equals(other._pages, _pages));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_books),
      const DeepCollectionEquality().hash(_pages));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookListResponseImplCopyWith<_$BookListResponseImpl> get copyWith =>
      __$$BookListResponseImplCopyWithImpl<_$BookListResponseImpl>(
          this, _$identity);
}

abstract class _BookListResponse implements BookListResponse {
  const factory _BookListResponse(
      {required final List<BookShortInfo> books,
      required final List<PageForPagination> pages}) = _$BookListResponseImpl;

  @override
  List<BookShortInfo> get books;
  @override
  List<PageForPagination> get pages;
  @override
  @JsonKey(ignore: true)
  _$$BookListResponseImplCopyWith<_$BookListResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookDetailInfo {
  int get id => throw _privateConstructorUsedError;
  DateTime get created => throw _privateConstructorUsedError;
  String? get previewUrl => throw _privateConstructorUsedError;
  bool get parsedName => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get parsedPage => throw _privateConstructorUsedError;
  int get pageCount => throw _privateConstructorUsedError;
  double get pageLoadedPercent => throw _privateConstructorUsedError;
  int get rate => throw _privateConstructorUsedError;
  List<BookDetailPagePreview>? get pages => throw _privateConstructorUsedError;
  List<BookDetailAttributeInfo>? get attributes =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookDetailInfoCopyWith<BookDetailInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookDetailInfoCopyWith<$Res> {
  factory $BookDetailInfoCopyWith(
          BookDetailInfo value, $Res Function(BookDetailInfo) then) =
      _$BookDetailInfoCopyWithImpl<$Res, BookDetailInfo>;
  @useResult
  $Res call(
      {int id,
      DateTime created,
      String? previewUrl,
      bool parsedName,
      String name,
      bool parsedPage,
      int pageCount,
      double pageLoadedPercent,
      int rate,
      List<BookDetailPagePreview>? pages,
      List<BookDetailAttributeInfo>? attributes});
}

/// @nodoc
class _$BookDetailInfoCopyWithImpl<$Res, $Val extends BookDetailInfo>
    implements $BookDetailInfoCopyWith<$Res> {
  _$BookDetailInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? previewUrl = freezed,
    Object? parsedName = null,
    Object? name = null,
    Object? parsedPage = null,
    Object? pageCount = null,
    Object? pageLoadedPercent = null,
    Object? rate = null,
    Object? pages = freezed,
    Object? attributes = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as DateTime,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      parsedName: null == parsedName
          ? _value.parsedName
          : parsedName // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parsedPage: null == parsedPage
          ? _value.parsedPage
          : parsedPage // ignore: cast_nullable_to_non_nullable
              as bool,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageLoadedPercent: null == pageLoadedPercent
          ? _value.pageLoadedPercent
          : pageLoadedPercent // ignore: cast_nullable_to_non_nullable
              as double,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
      pages: freezed == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<BookDetailPagePreview>?,
      attributes: freezed == attributes
          ? _value.attributes
          : attributes // ignore: cast_nullable_to_non_nullable
              as List<BookDetailAttributeInfo>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookDetailInfoImplCopyWith<$Res>
    implements $BookDetailInfoCopyWith<$Res> {
  factory _$$BookDetailInfoImplCopyWith(_$BookDetailInfoImpl value,
          $Res Function(_$BookDetailInfoImpl) then) =
      __$$BookDetailInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      DateTime created,
      String? previewUrl,
      bool parsedName,
      String name,
      bool parsedPage,
      int pageCount,
      double pageLoadedPercent,
      int rate,
      List<BookDetailPagePreview>? pages,
      List<BookDetailAttributeInfo>? attributes});
}

/// @nodoc
class __$$BookDetailInfoImplCopyWithImpl<$Res>
    extends _$BookDetailInfoCopyWithImpl<$Res, _$BookDetailInfoImpl>
    implements _$$BookDetailInfoImplCopyWith<$Res> {
  __$$BookDetailInfoImplCopyWithImpl(
      _$BookDetailInfoImpl _value, $Res Function(_$BookDetailInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? created = null,
    Object? previewUrl = freezed,
    Object? parsedName = null,
    Object? name = null,
    Object? parsedPage = null,
    Object? pageCount = null,
    Object? pageLoadedPercent = null,
    Object? rate = null,
    Object? pages = freezed,
    Object? attributes = freezed,
  }) {
    return _then(_$BookDetailInfoImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      created: null == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as DateTime,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      parsedName: null == parsedName
          ? _value.parsedName
          : parsedName // ignore: cast_nullable_to_non_nullable
              as bool,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      parsedPage: null == parsedPage
          ? _value.parsedPage
          : parsedPage // ignore: cast_nullable_to_non_nullable
              as bool,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageLoadedPercent: null == pageLoadedPercent
          ? _value.pageLoadedPercent
          : pageLoadedPercent // ignore: cast_nullable_to_non_nullable
              as double,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
      pages: freezed == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<BookDetailPagePreview>?,
      attributes: freezed == attributes
          ? _value._attributes
          : attributes // ignore: cast_nullable_to_non_nullable
              as List<BookDetailAttributeInfo>?,
    ));
  }
}

/// @nodoc

class _$BookDetailInfoImpl
    with DiagnosticableTreeMixin
    implements _BookDetailInfo {
  const _$BookDetailInfoImpl(
      {required this.id,
      required this.created,
      this.previewUrl,
      required this.parsedName,
      required this.name,
      required this.parsedPage,
      required this.pageCount,
      required this.pageLoadedPercent,
      required this.rate,
      final List<BookDetailPagePreview>? pages,
      final List<BookDetailAttributeInfo>? attributes})
      : _pages = pages,
        _attributes = attributes;

  @override
  final int id;
  @override
  final DateTime created;
  @override
  final String? previewUrl;
  @override
  final bool parsedName;
  @override
  final String name;
  @override
  final bool parsedPage;
  @override
  final int pageCount;
  @override
  final double pageLoadedPercent;
  @override
  final int rate;
  final List<BookDetailPagePreview>? _pages;
  @override
  List<BookDetailPagePreview>? get pages {
    final value = _pages;
    if (value == null) return null;
    if (_pages is EqualUnmodifiableListView) return _pages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<BookDetailAttributeInfo>? _attributes;
  @override
  List<BookDetailAttributeInfo>? get attributes {
    final value = _attributes;
    if (value == null) return null;
    if (_attributes is EqualUnmodifiableListView) return _attributes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BookDetailInfo(id: $id, created: $created, previewUrl: $previewUrl, parsedName: $parsedName, name: $name, parsedPage: $parsedPage, pageCount: $pageCount, pageLoadedPercent: $pageLoadedPercent, rate: $rate, pages: $pages, attributes: $attributes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BookDetailInfo'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('created', created))
      ..add(DiagnosticsProperty('previewUrl', previewUrl))
      ..add(DiagnosticsProperty('parsedName', parsedName))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('parsedPage', parsedPage))
      ..add(DiagnosticsProperty('pageCount', pageCount))
      ..add(DiagnosticsProperty('pageLoadedPercent', pageLoadedPercent))
      ..add(DiagnosticsProperty('rate', rate))
      ..add(DiagnosticsProperty('pages', pages))
      ..add(DiagnosticsProperty('attributes', attributes));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookDetailInfoImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.previewUrl, previewUrl) ||
                other.previewUrl == previewUrl) &&
            (identical(other.parsedName, parsedName) ||
                other.parsedName == parsedName) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parsedPage, parsedPage) ||
                other.parsedPage == parsedPage) &&
            (identical(other.pageCount, pageCount) ||
                other.pageCount == pageCount) &&
            (identical(other.pageLoadedPercent, pageLoadedPercent) ||
                other.pageLoadedPercent == pageLoadedPercent) &&
            (identical(other.rate, rate) || other.rate == rate) &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            const DeepCollectionEquality()
                .equals(other._attributes, _attributes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      created,
      previewUrl,
      parsedName,
      name,
      parsedPage,
      pageCount,
      pageLoadedPercent,
      rate,
      const DeepCollectionEquality().hash(_pages),
      const DeepCollectionEquality().hash(_attributes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookDetailInfoImplCopyWith<_$BookDetailInfoImpl> get copyWith =>
      __$$BookDetailInfoImplCopyWithImpl<_$BookDetailInfoImpl>(
          this, _$identity);
}

abstract class _BookDetailInfo implements BookDetailInfo {
  const factory _BookDetailInfo(
      {required final int id,
      required final DateTime created,
      final String? previewUrl,
      required final bool parsedName,
      required final String name,
      required final bool parsedPage,
      required final int pageCount,
      required final double pageLoadedPercent,
      required final int rate,
      final List<BookDetailPagePreview>? pages,
      final List<BookDetailAttributeInfo>? attributes}) = _$BookDetailInfoImpl;

  @override
  int get id;
  @override
  DateTime get created;
  @override
  String? get previewUrl;
  @override
  bool get parsedName;
  @override
  String get name;
  @override
  bool get parsedPage;
  @override
  int get pageCount;
  @override
  double get pageLoadedPercent;
  @override
  int get rate;
  @override
  List<BookDetailPagePreview>? get pages;
  @override
  List<BookDetailAttributeInfo>? get attributes;
  @override
  @JsonKey(ignore: true)
  _$$BookDetailInfoImplCopyWith<_$BookDetailInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookDetailPagePreview {
  int get pageNumber => throw _privateConstructorUsedError;
  String? get previewUrl => throw _privateConstructorUsedError;
  int get rate => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookDetailPagePreviewCopyWith<BookDetailPagePreview> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookDetailPagePreviewCopyWith<$Res> {
  factory $BookDetailPagePreviewCopyWith(BookDetailPagePreview value,
          $Res Function(BookDetailPagePreview) then) =
      _$BookDetailPagePreviewCopyWithImpl<$Res, BookDetailPagePreview>;
  @useResult
  $Res call({int pageNumber, String? previewUrl, int rate});
}

/// @nodoc
class _$BookDetailPagePreviewCopyWithImpl<$Res,
        $Val extends BookDetailPagePreview>
    implements $BookDetailPagePreviewCopyWith<$Res> {
  _$BookDetailPagePreviewCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = null,
    Object? previewUrl = freezed,
    Object? rate = null,
  }) {
    return _then(_value.copyWith(
      pageNumber: null == pageNumber
          ? _value.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookDetailPagePreviewImplCopyWith<$Res>
    implements $BookDetailPagePreviewCopyWith<$Res> {
  factory _$$BookDetailPagePreviewImplCopyWith(
          _$BookDetailPagePreviewImpl value,
          $Res Function(_$BookDetailPagePreviewImpl) then) =
      __$$BookDetailPagePreviewImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int pageNumber, String? previewUrl, int rate});
}

/// @nodoc
class __$$BookDetailPagePreviewImplCopyWithImpl<$Res>
    extends _$BookDetailPagePreviewCopyWithImpl<$Res,
        _$BookDetailPagePreviewImpl>
    implements _$$BookDetailPagePreviewImplCopyWith<$Res> {
  __$$BookDetailPagePreviewImplCopyWithImpl(_$BookDetailPagePreviewImpl _value,
      $Res Function(_$BookDetailPagePreviewImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageNumber = null,
    Object? previewUrl = freezed,
    Object? rate = null,
  }) {
    return _then(_$BookDetailPagePreviewImpl(
      pageNumber: null == pageNumber
          ? _value.pageNumber
          : pageNumber // ignore: cast_nullable_to_non_nullable
              as int,
      previewUrl: freezed == previewUrl
          ? _value.previewUrl
          : previewUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      rate: null == rate
          ? _value.rate
          : rate // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BookDetailPagePreviewImpl
    with DiagnosticableTreeMixin
    implements _BookDetailPagePreview {
  const _$BookDetailPagePreviewImpl(
      {required this.pageNumber, this.previewUrl, required this.rate});

  @override
  final int pageNumber;
  @override
  final String? previewUrl;
  @override
  final int rate;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BookDetailPagePreview(pageNumber: $pageNumber, previewUrl: $previewUrl, rate: $rate)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BookDetailPagePreview'))
      ..add(DiagnosticsProperty('pageNumber', pageNumber))
      ..add(DiagnosticsProperty('previewUrl', previewUrl))
      ..add(DiagnosticsProperty('rate', rate));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookDetailPagePreviewImpl &&
            (identical(other.pageNumber, pageNumber) ||
                other.pageNumber == pageNumber) &&
            (identical(other.previewUrl, previewUrl) ||
                other.previewUrl == previewUrl) &&
            (identical(other.rate, rate) || other.rate == rate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pageNumber, previewUrl, rate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookDetailPagePreviewImplCopyWith<_$BookDetailPagePreviewImpl>
      get copyWith => __$$BookDetailPagePreviewImplCopyWithImpl<
          _$BookDetailPagePreviewImpl>(this, _$identity);
}

abstract class _BookDetailPagePreview implements BookDetailPagePreview {
  const factory _BookDetailPagePreview(
      {required final int pageNumber,
      final String? previewUrl,
      required final int rate}) = _$BookDetailPagePreviewImpl;

  @override
  int get pageNumber;
  @override
  String? get previewUrl;
  @override
  int get rate;
  @override
  @JsonKey(ignore: true)
  _$$BookDetailPagePreviewImplCopyWith<_$BookDetailPagePreviewImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookDetailAttributeInfo {
  String get name => throw _privateConstructorUsedError;
  List<String> get values => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BookDetailAttributeInfoCopyWith<BookDetailAttributeInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookDetailAttributeInfoCopyWith<$Res> {
  factory $BookDetailAttributeInfoCopyWith(BookDetailAttributeInfo value,
          $Res Function(BookDetailAttributeInfo) then) =
      _$BookDetailAttributeInfoCopyWithImpl<$Res, BookDetailAttributeInfo>;
  @useResult
  $Res call({String name, List<String> values});
}

/// @nodoc
class _$BookDetailAttributeInfoCopyWithImpl<$Res,
        $Val extends BookDetailAttributeInfo>
    implements $BookDetailAttributeInfoCopyWith<$Res> {
  _$BookDetailAttributeInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? values = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      values: null == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookDetailAttributeInfoImplCopyWith<$Res>
    implements $BookDetailAttributeInfoCopyWith<$Res> {
  factory _$$BookDetailAttributeInfoImplCopyWith(
          _$BookDetailAttributeInfoImpl value,
          $Res Function(_$BookDetailAttributeInfoImpl) then) =
      __$$BookDetailAttributeInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, List<String> values});
}

/// @nodoc
class __$$BookDetailAttributeInfoImplCopyWithImpl<$Res>
    extends _$BookDetailAttributeInfoCopyWithImpl<$Res,
        _$BookDetailAttributeInfoImpl>
    implements _$$BookDetailAttributeInfoImplCopyWith<$Res> {
  __$$BookDetailAttributeInfoImplCopyWithImpl(
      _$BookDetailAttributeInfoImpl _value,
      $Res Function(_$BookDetailAttributeInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? values = null,
  }) {
    return _then(_$BookDetailAttributeInfoImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      values: null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$BookDetailAttributeInfoImpl
    with DiagnosticableTreeMixin
    implements _BookDetailAttributeInfo {
  const _$BookDetailAttributeInfoImpl(
      {required this.name, required final List<String> values})
      : _values = values;

  @override
  final String name;
  final List<String> _values;
  @override
  List<String> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BookDetailAttributeInfo(name: $name, values: $values)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BookDetailAttributeInfo'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('values', values));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookDetailAttributeInfoImpl &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._values, _values));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, name, const DeepCollectionEquality().hash(_values));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookDetailAttributeInfoImplCopyWith<_$BookDetailAttributeInfoImpl>
      get copyWith => __$$BookDetailAttributeInfoImplCopyWithImpl<
          _$BookDetailAttributeInfoImpl>(this, _$identity);
}

abstract class _BookDetailAttributeInfo implements BookDetailAttributeInfo {
  const factory _BookDetailAttributeInfo(
      {required final String name,
      required final List<String> values}) = _$BookDetailAttributeInfoImpl;

  @override
  String get name;
  @override
  List<String> get values;
  @override
  @JsonKey(ignore: true)
  _$$BookDetailAttributeInfoImplCopyWith<_$BookDetailAttributeInfoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Worker {
  String get name => throw _privateConstructorUsedError;
  int get inQueue => throw _privateConstructorUsedError;
  int get inWork => throw _privateConstructorUsedError;
  int get runners => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WorkerCopyWith<Worker> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkerCopyWith<$Res> {
  factory $WorkerCopyWith(Worker value, $Res Function(Worker) then) =
      _$WorkerCopyWithImpl<$Res, Worker>;
  @useResult
  $Res call({String name, int inQueue, int inWork, int runners});
}

/// @nodoc
class _$WorkerCopyWithImpl<$Res, $Val extends Worker>
    implements $WorkerCopyWith<$Res> {
  _$WorkerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? inQueue = null,
    Object? inWork = null,
    Object? runners = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      inQueue: null == inQueue
          ? _value.inQueue
          : inQueue // ignore: cast_nullable_to_non_nullable
              as int,
      inWork: null == inWork
          ? _value.inWork
          : inWork // ignore: cast_nullable_to_non_nullable
              as int,
      runners: null == runners
          ? _value.runners
          : runners // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WorkerImplCopyWith<$Res> implements $WorkerCopyWith<$Res> {
  factory _$$WorkerImplCopyWith(
          _$WorkerImpl value, $Res Function(_$WorkerImpl) then) =
      __$$WorkerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, int inQueue, int inWork, int runners});
}

/// @nodoc
class __$$WorkerImplCopyWithImpl<$Res>
    extends _$WorkerCopyWithImpl<$Res, _$WorkerImpl>
    implements _$$WorkerImplCopyWith<$Res> {
  __$$WorkerImplCopyWithImpl(
      _$WorkerImpl _value, $Res Function(_$WorkerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? inQueue = null,
    Object? inWork = null,
    Object? runners = null,
  }) {
    return _then(_$WorkerImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      inQueue: null == inQueue
          ? _value.inQueue
          : inQueue // ignore: cast_nullable_to_non_nullable
              as int,
      inWork: null == inWork
          ? _value.inWork
          : inWork // ignore: cast_nullable_to_non_nullable
              as int,
      runners: null == runners
          ? _value.runners
          : runners // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WorkerImpl with DiagnosticableTreeMixin implements _Worker {
  const _$WorkerImpl(
      {required this.name,
      required this.inQueue,
      required this.inWork,
      required this.runners});

  @override
  final String name;
  @override
  final int inQueue;
  @override
  final int inWork;
  @override
  final int runners;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Worker(name: $name, inQueue: $inQueue, inWork: $inWork, runners: $runners)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Worker'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('inQueue', inQueue))
      ..add(DiagnosticsProperty('inWork', inWork))
      ..add(DiagnosticsProperty('runners', runners));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkerImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.inQueue, inQueue) || other.inQueue == inQueue) &&
            (identical(other.inWork, inWork) || other.inWork == inWork) &&
            (identical(other.runners, runners) || other.runners == runners));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, inQueue, inWork, runners);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkerImplCopyWith<_$WorkerImpl> get copyWith =>
      __$$WorkerImplCopyWithImpl<_$WorkerImpl>(this, _$identity);
}

abstract class _Worker implements Worker {
  const factory _Worker(
      {required final String name,
      required final int inQueue,
      required final int inWork,
      required final int runners}) = _$WorkerImpl;

  @override
  String get name;
  @override
  int get inQueue;
  @override
  int get inWork;
  @override
  int get runners;
  @override
  @JsonKey(ignore: true)
  _$$WorkerImplCopyWith<_$WorkerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Dashboard {
  List<Worker>? get workers => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;
  int get notLoadCount => throw _privateConstructorUsedError;
  int get notLoadPageCount => throw _privateConstructorUsedError;
  int get pageCount => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DashboardCopyWith<Dashboard> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DashboardCopyWith<$Res> {
  factory $DashboardCopyWith(Dashboard value, $Res Function(Dashboard) then) =
      _$DashboardCopyWithImpl<$Res, Dashboard>;
  @useResult
  $Res call(
      {List<Worker>? workers,
      int count,
      int notLoadCount,
      int notLoadPageCount,
      int pageCount});
}

/// @nodoc
class _$DashboardCopyWithImpl<$Res, $Val extends Dashboard>
    implements $DashboardCopyWith<$Res> {
  _$DashboardCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workers = freezed,
    Object? count = null,
    Object? notLoadCount = null,
    Object? notLoadPageCount = null,
    Object? pageCount = null,
  }) {
    return _then(_value.copyWith(
      workers: freezed == workers
          ? _value.workers
          : workers // ignore: cast_nullable_to_non_nullable
              as List<Worker>?,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      notLoadCount: null == notLoadCount
          ? _value.notLoadCount
          : notLoadCount // ignore: cast_nullable_to_non_nullable
              as int,
      notLoadPageCount: null == notLoadPageCount
          ? _value.notLoadPageCount
          : notLoadPageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DashboardImplCopyWith<$Res>
    implements $DashboardCopyWith<$Res> {
  factory _$$DashboardImplCopyWith(
          _$DashboardImpl value, $Res Function(_$DashboardImpl) then) =
      __$$DashboardImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<Worker>? workers,
      int count,
      int notLoadCount,
      int notLoadPageCount,
      int pageCount});
}

/// @nodoc
class __$$DashboardImplCopyWithImpl<$Res>
    extends _$DashboardCopyWithImpl<$Res, _$DashboardImpl>
    implements _$$DashboardImplCopyWith<$Res> {
  __$$DashboardImplCopyWithImpl(
      _$DashboardImpl _value, $Res Function(_$DashboardImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? workers = freezed,
    Object? count = null,
    Object? notLoadCount = null,
    Object? notLoadPageCount = null,
    Object? pageCount = null,
  }) {
    return _then(_$DashboardImpl(
      workers: freezed == workers
          ? _value._workers
          : workers // ignore: cast_nullable_to_non_nullable
              as List<Worker>?,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      notLoadCount: null == notLoadCount
          ? _value.notLoadCount
          : notLoadCount // ignore: cast_nullable_to_non_nullable
              as int,
      notLoadPageCount: null == notLoadPageCount
          ? _value.notLoadPageCount
          : notLoadPageCount // ignore: cast_nullable_to_non_nullable
              as int,
      pageCount: null == pageCount
          ? _value.pageCount
          : pageCount // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$DashboardImpl with DiagnosticableTreeMixin implements _Dashboard {
  const _$DashboardImpl(
      {final List<Worker>? workers,
      required this.count,
      required this.notLoadCount,
      required this.notLoadPageCount,
      required this.pageCount})
      : _workers = workers;

  final List<Worker>? _workers;
  @override
  List<Worker>? get workers {
    final value = _workers;
    if (value == null) return null;
    if (_workers is EqualUnmodifiableListView) return _workers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int count;
  @override
  final int notLoadCount;
  @override
  final int notLoadPageCount;
  @override
  final int pageCount;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Dashboard(workers: $workers, count: $count, notLoadCount: $notLoadCount, notLoadPageCount: $notLoadPageCount, pageCount: $pageCount)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Dashboard'))
      ..add(DiagnosticsProperty('workers', workers))
      ..add(DiagnosticsProperty('count', count))
      ..add(DiagnosticsProperty('notLoadCount', notLoadCount))
      ..add(DiagnosticsProperty('notLoadPageCount', notLoadPageCount))
      ..add(DiagnosticsProperty('pageCount', pageCount));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DashboardImpl &&
            const DeepCollectionEquality().equals(other._workers, _workers) &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.notLoadCount, notLoadCount) ||
                other.notLoadCount == notLoadCount) &&
            (identical(other.notLoadPageCount, notLoadPageCount) ||
                other.notLoadPageCount == notLoadPageCount) &&
            (identical(other.pageCount, pageCount) ||
                other.pageCount == pageCount));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_workers),
      count,
      notLoadCount,
      notLoadPageCount,
      pageCount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DashboardImplCopyWith<_$DashboardImpl> get copyWith =>
      __$$DashboardImplCopyWithImpl<_$DashboardImpl>(this, _$identity);
}

abstract class _Dashboard implements Dashboard {
  const factory _Dashboard(
      {final List<Worker>? workers,
      required final int count,
      required final int notLoadCount,
      required final int notLoadPageCount,
      required final int pageCount}) = _$DashboardImpl;

  @override
  List<Worker>? get workers;
  @override
  int get count;
  @override
  int get notLoadCount;
  @override
  int get notLoadPageCount;
  @override
  int get pageCount;
  @override
  @JsonKey(ignore: true)
  _$$DashboardImplCopyWith<_$DashboardImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
